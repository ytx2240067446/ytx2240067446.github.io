<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>逆...逆不出来了 | Bi0x</title><meta name="description" content="逆...逆不出来了"><meta name="keywords" content="Re"><meta name="author" content="Bi0x,bi0x@foxmail.com"><meta name="copyright" content="Bi0x"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon1.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="逆...逆不出来了"><meta name="twitter:description" content="逆...逆不出来了"><meta name="twitter:image" content="http://www.bi0x.cn/images/pasted-36.png"><meta property="og:type" content="article"><meta property="og:title" content="逆...逆不出来了"><meta property="og:url" content="http://www.bi0x.cn/2020/04/02/reverse1/"><meta property="og:site_name" content="Bi0x"><meta property="og:description" content="逆...逆不出来了"><meta property="og:image" content="http://www.bi0x.cn/images/pasted-36.png"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      now = new Date();
      hour = now.getHours();
      isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="canonical" href="http://www.bi0x.cn/2020/04/02/reverse1/"><link rel="prev" title="蟒蛇们" href="http://www.bi0x.cn/2020/04/13/python1/"><link rel="next" title="各种栈溢出" href="http://www.bi0x.cn/2020/03/31/stack-overflow/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://www.bi0x.cn/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"title":"Snackbar.bookmark.title","message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: false,
  isFontAwesomeV5: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false
}</script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Bi0x" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar1.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">8</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">5</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 小伙伴</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基础知识"><span class="toc-number">1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#字符编码"><span class="toc-number">1.1.</span> <span class="toc-text">字符编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Windows-操作系统"><span class="toc-number">1.2.</span> <span class="toc-text">Windows 操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Win32-API"><span class="toc-number">1.2.1.</span> <span class="toc-text">Win32 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#消息机制"><span class="toc-number">1.2.2.</span> <span class="toc-text">消息机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟内存-（Windows-32-位系统中）"><span class="toc-number">1.2.3.</span> <span class="toc-text">虚拟内存 （Windows 32 位系统中）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#OllyDbg-调试器"><span class="toc-number">2.</span> <span class="toc-text">OllyDbg 调试器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本操作"><span class="toc-number">2.1.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#快捷键"><span class="toc-number">2.1.1.</span> <span class="toc-text">快捷键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作"><span class="toc-number">2.1.2.</span> <span class="toc-text">操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用断点"><span class="toc-number">2.2.</span> <span class="toc-text">常用断点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#INT-3-断点"><span class="toc-number">2.2.1.</span> <span class="toc-text">INT 3 断点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#硬件断点"><span class="toc-number">2.2.2.</span> <span class="toc-text">硬件断点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存断点"><span class="toc-number">2.2.3.</span> <span class="toc-text">内存断点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存访问一次性断点"><span class="toc-number">2.2.4.</span> <span class="toc-text">内存访问一次性断点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#消息断点"><span class="toc-number">2.2.5.</span> <span class="toc-text">消息断点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条件断点"><span class="toc-number">2.2.6.</span> <span class="toc-text">条件断点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#条件记录断点"><span class="toc-number">2.2.7.</span> <span class="toc-text">条件记录断点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#插件"><span class="toc-number">2.3.</span> <span class="toc-text">插件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CmdBar-插件"><span class="toc-number">2.3.1.</span> <span class="toc-text">CmdBar 插件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Run-Trace"><span class="toc-number">2.4.</span> <span class="toc-text">Run Trace</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hit-Trace"><span class="toc-number">2.5.</span> <span class="toc-text">Hit Trace</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#加载程序"><span class="toc-number">2.6.</span> <span class="toc-text">加载程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通过-CreateProcess-创建进程"><span class="toc-number">2.6.1.</span> <span class="toc-text">通过 CreateProcess 创建进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过-DebugActiveProcess-附在正在运行的进程上"><span class="toc-number">2.6.2.</span> <span class="toc-text">通过 DebugActiveProcess 附在正在运行的进程上</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OllyDbg-常见问题"><span class="toc-number">2.7.</span> <span class="toc-text">OllyDbg 常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#乱码问题"><span class="toc-number">2.7.1.</span> <span class="toc-text">乱码问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快速回到程序领空"><span class="toc-number">2.7.2.</span> <span class="toc-text">快速回到程序领空</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修改-EIP-的值"><span class="toc-number">2.7.3.</span> <span class="toc-text">修改 EIP 的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在反汇编窗口输入-push-E000-之类的指令报错"><span class="toc-number">2.7.4.</span> <span class="toc-text">在反汇编窗口输入 push E000 之类的指令报错</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重命名-call-函数名"><span class="toc-number">2.7.5.</span> <span class="toc-text">重命名 call 函数名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置-OllyDbg-为即时调试器"><span class="toc-number">2.7.6.</span> <span class="toc-text">设置 OllyDbg 为即时调试器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IDA"><span class="toc-number">3.</span> <span class="toc-text">IDA</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#导航栏"><span class="toc-number">3.1.</span> <span class="toc-text">导航栏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#输入函数"><span class="toc-number">3.2.</span> <span class="toc-text">输入函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#跳转到目标地址"><span class="toc-number">3.3.</span> <span class="toc-text">跳转到目标地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#交叉参考-XREF"><span class="toc-number">3.4.</span> <span class="toc-text">交叉参考 (XREF)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#参考重命名"><span class="toc-number">3.4.1.</span> <span class="toc-text">参考重命名</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#标签"><span class="toc-number">3.5.</span> <span class="toc-text">标签</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#格式化指令操作数"><span class="toc-number">3.6.</span> <span class="toc-text">格式化指令操作数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码和数据转换"><span class="toc-number">3.7.</span> <span class="toc-text">代码和数据转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组处理"><span class="toc-number">3.8.</span> <span class="toc-text">数组处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结构体处理"><span class="toc-number">3.9.</span> <span class="toc-text">结构体处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#导入结构体"><span class="toc-number">3.9.1.</span> <span class="toc-text">导入结构体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#枚举类型处理"><span class="toc-number">3.10.</span> <span class="toc-text">枚举类型处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#库文件快速识别与鉴定技术-FLIRT"><span class="toc-number">3.11.</span> <span class="toc-text">库文件快速识别与鉴定技术 (FLIRT)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IDA-调试器"><span class="toc-number">3.12.</span> <span class="toc-text">IDA 调试器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#修补程序"><span class="toc-number">3.13.</span> <span class="toc-text">修补程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重新设置基址"><span class="toc-number">3.14.</span> <span class="toc-text">重新设置基址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数调用"><span class="toc-number">3.15.</span> <span class="toc-text">函数调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数的参数"><span class="toc-number">3.15.1.</span> <span class="toc-text">函数的参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用栈传递参数"><span class="toc-number">3.15.2.</span> <span class="toc-text">利用栈传递参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#利用寄存器传递参数"><span class="toc-number">3.15.3.</span> <span class="toc-text">利用寄存器传递参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据结构"><span class="toc-number">3.16.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚函数"><span class="toc-number">3.17.</span> <span class="toc-text">虚函数</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/images/pasted-36.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bi0x</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 小伙伴</span></a></div></div></span></div><div id="post-info"><div id="post-title"><div class="posttitle">逆...逆不出来了</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-04-02<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-04-13</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/CTF/">CTF</a></span><div class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">6.3k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 20 分钟</span><div class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2020/04/02/reverse1/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/04/02/reverse1/" itemprop="commentCount"></span></a></div></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><ul>
<li><p>Windows 在存储 Unicode 字符时使用的是<strong>小端序 </strong>(Little-endian)</p>
</li>
<li><p>小端序就是低字节位存储在低地址位，一般 x86 CPU 这些的都是小端序</p>
<ul>
<li>例如 0x11223344</li>
<li><p>内存中是这样存储的</p>
<p>| 地址 | t + 0x00 | t + 0x01 | t + 0x02 | t + 0x03 |<br>| —— | ———— | ———— | ———— | ———— |<br>| 内容 | 0x44     | 0x33     | 0x22     | 0x11     |</p>
</li>
</ul>
</li>
<li><p>大端序是高字节位存储在低地址位</p>
<ul>
<li>例如 0x11223344</li>
<li><p>内存中是这样存储的</p>
<p>| 地址 | t + 0x00 | t + 0x01 | t + 0x02 | t + 0x03 |<br>| —— | ———— | ———— | ———— | ———— |<br>| 内容 | 0x11     | 0x22     | 0x33     | 0x44     |</p>
</li>
</ul>
</li>
<li><p>Little-endian 和 Big-endian 取自《格列佛游记》，吃蛋从大的一端剥开和小的一端剥开的纷争</p>
</li>
<li><p>Windows 3.1 开始更名为 Windows NT 3.1后（Win95 之前的一代）就使用 Unicode 字符集重新开发了，如果给 Windows 传递一个 ANSI 字符串，Windows 会将其转换成 Unicode 字符串后再进行处理</p>
</li>
<li><p>如果希望某个函数返回的是 ANSI 格式的字符串，Windows 会讲其处理出来的 Unicode 字符串转换成 ANSI 字符串，再进行函数的返回操作，<strong>会影响性能</strong></p>
<ul>
<li>因此 ANSI 版的应用程序需要更多的内存和 CPU 资源，而 Unicode 版的执行效率会高一点</li>
</ul>
</li>
</ul>
<h2 id="Windows-操作系统"><a href="#Windows-操作系统" class="headerlink" title="Windows 操作系统"></a>Windows 操作系统</h2><h3 id="Win32-API"><a href="#Win32-API" class="headerlink" title="Win32 API"></a>Win32 API</h3><ul>
<li>API 全称是应用程序编程接口</li>
<li>参考 Win32 API 参考文档 和 《Windows 程序设计》</li>
<li>64 位 Windows 的系统文件放在 System32 里，SysWOW64 存的是 64 位系统对 32 位系统兼容用的文件</li>
<li>Win 32 是支持 16 位的应用程序的运行的，但是 WOW64 不支持 16 位系统的运行，也不支持 32 位内核模式的设备驱动程序，WOW64 只能加载 32 位的 DLL, 不能加载 64 位的 DLL</li>
</ul>
<h3 id="消息机制"><a href="#消息机制" class="headerlink" title="消息机制"></a>消息机制</h3><ul>
<li>Windows 是消息驱动型系统，系统中有两个消息队列，一个是系统消息队列，另一个是应用程序消息队列。</li>
<li>当一个事件发生时，Windows 先将输入的消息放入系统消息队列，再将输入的消息复制到相应的应用程序队列中，<strong>顺序是按照消息进入的先后顺序排队的</strong></li>
</ul>
<h3 id="虚拟内存-（Windows-32-位系统中）"><a href="#虚拟内存-（Windows-32-位系统中）" class="headerlink" title="虚拟内存 （Windows 32 位系统中）"></a>虚拟内存 （Windows 32 位系统中）</h3><ul>
<li>一个应用程序启动时，操作系统会创建一个进程，并给此进程分配 2GB 的虚拟地址（<strong>不是映射到物理内存中</strong>)</li>
<li>虚拟内存管理器将应用程序的代码映射到那个应用程序的虚拟地址中的某个位置，并把当前的代码读入物理内存<ul>
<li>如果有使用到 DLL，DLL 也会被映射到进程的虚拟地址空间中，在需要的时候被读入物理内存</li>
</ul>
</li>
<li>数据、堆栈等内容是从物理内存中分配，并映射到虚拟地址空间中的</li>
<li>程序通过其虚拟地址空间的地址开始执行，然后内存管理器每次都把虚拟地址空间中的内存映射到物理位置中</li>
<li><p>需要注意</p>
<ul>
<li><strong>应用程序不会直接访问物理地址</strong></li>
<li><strong>虚拟内存管理器通过虚拟地址的访问请求来控制所有的物理地址的访问</strong></li>
<li>在 32 位系统中，每个应用程序都有独立的 4GB 寻址空间，<strong>不同应用程序见的地址空间时彼此隔离的</strong></li>
<li>DLL 就没有私有空间了，<strong>它会被映射到需要它的应用程序的地址空间中去</strong>，作为其他应用程序的一部分运行，如果它不在需要调用此 DLL 的内存空间中，则其无法被对应应用程序调用</li>
</ul>
</li>
<li><p><font color=red><strong>64位系统的最大寻址空间是 16 TB</strong> </font></p>
<ul>
<li>Windows 7 x64 支持最大 192GB 内存</li>
<li>Windows 10 x64 支持最大 2TB 内存</li>
</ul>
</li>
</ul>
<h1 id="OllyDbg-调试器"><a href="#OllyDbg-调试器" class="headerlink" title="OllyDbg 调试器"></a>OllyDbg 调试器</h1><ul>
<li>此调试器<font color=red><strong>只能调试 32 位 Windows 应用程序</strong></font></li>
<li>上方按钮中的英文字母为窗口切换用，其中主窗口 LCG 是 “c”</li>
</ul>
<p><img src="/" alt="" class="lazyload" data-src="/images/pasted-10.png"></p>
<ul>
<li><p>LCG 中左上方为反汇编面板，其中四列分别是地址，十六进制机器码，反汇编代码，注释</p>
<ul>
<li>注释中显示了相关的 API 参数或者运行的简表</li>
<li>设置汇编代码断点，<strong>快捷键为 F2</strong></li>
<li>在此处也可以直接修改汇编代码，<strong>快捷键 空格</strong> </li>
</ul>
</li>
<li><p>左下方为数据面板，其以 16 进制和字符的形式显示内存中的数据，可以通过 Win + G 跳转到指定地址的查看内容。</p>
</li>
<li><p>右上方为寄存器面板，可以通过右键切换显示各种类型寄存器的值</p>
</li>
<li><p>右下方为栈面板，显示 ESP 指向地址的内容</p>
</li>
<li><p><strong>可以在 Option 中将 OllyDbg 添加到右键菜单中</strong></p>
</li>
<li>可以在 Option 的  Event 中将调试程序的中断入口点下在 WinMain</li>
</ul>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><div class="table-container">
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>F2</td>
<td>设置软件断点</td>
<td></td>
</tr>
<tr>
<td>F3</td>
<td>打开一个新的可执行程序</td>
<td></td>
</tr>
<tr>
<td>F4</td>
<td>程序执行到光标处</td>
<td></td>
</tr>
<tr>
<td>F5</td>
<td>缩小、还原当前窗口</td>
<td></td>
</tr>
<tr>
<td>F7</td>
<td>单步步入函数</td>
<td>遇到 call 指令跟进</td>
</tr>
<tr>
<td>F8</td>
<td>单步步过函数</td>
<td>遇到 call 指令不跟进</td>
</tr>
<tr>
<td>F9</td>
<td>运行程序到断点处</td>
<td></td>
</tr>
<tr>
<td>F12</td>
<td>暂停程序</td>
<td></td>
</tr>
<tr>
<td>Ctrl+F2</td>
<td>重新执行程序</td>
<td></td>
</tr>
<tr>
<td>Shift+F7</td>
<td>和F7一样 遇异常步入程序指定异常处理</td>
<td></td>
</tr>
<tr>
<td>Ctrl+F7</td>
<td>自动步入 直到断点或发生异常</td>
<td></td>
</tr>
<tr>
<td>Alt+F7</td>
<td>运行完系统 DLL 中的内容，返回到程序代码处</td>
<td></td>
</tr>
<tr>
<td>Shift+F8</td>
<td>和F8一样 遇异常步入程序指定异常处理</td>
<td></td>
</tr>
<tr>
<td>Ctrl+F8</td>
<td>自动步过 直到断点或发生异常</td>
<td></td>
</tr>
<tr>
<td>Ctrl+F9</td>
<td>运行到下一个return</td>
<td></td>
</tr>
<tr>
<td>Shift+F9</td>
<td>和F9一样 遇异常步入程序指定异常处理</td>
<td></td>
</tr>
<tr>
<td>Alt+B</td>
<td>显示所有断点，空格切换断点启用状态</td>
<td>会在关闭后保存</td>
</tr>
<tr>
<td>Ctrl+G</td>
<td>跳转到指定地址或 API 函数处</td>
<td></td>
</tr>
<tr>
<td>Ctrl+N</td>
<td>显示程序调用的所有 API 函数</td>
</tr>
</tbody>
</table>
</div>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul>
<li>LCG 窗口最左侧为虚拟地址，一般情况下一个程序的同一指令在不同系统环境下虚拟地址都是相同的</li>
<li>程序右侧为寄存器界面，其中 ESP 为栈顶指针，LCG 窗口右下角为栈中内容的窗口<ul>
<li>寄存器中的值一般都可以直接修改</li>
</ul>
</li>
<li><p><strong>EIP 指向程序将要执行的下一条指令，此值不可以通过输入数值来进行修改，但可以右键某条指令的虚拟地址，使用 “此处为新 EIP” (New origin here) 进行修改</strong></p>
</li>
<li><p>在单步步入 call 指令时，若需要会看之前跟踪代码时之前一条的汇编代码，可以使用 “-“ 键，若需要回到程序当前执行的位置，双击 EIP 寄存器的值就行</p>
</li>
<li><p>使用 Ctrl + F7 和 Ctrl + F8 可以让 OD 相对缓慢的逐行执行汇编程序，直到按下 Esc 或 F12 或 断点</p>
</li>
<li><p>使用 Ctrl + F9 可以让子函数运行到 return 处并暂停</p>
</li>
<li><p>Ctrl + G 还可以跳转到程序调用的指定 API 函数处</p>
<ul>
<li>例如，使用 Win + G 输入 GetDlgItemTextA 可以跳转到 USER32.DLL 中 ANSI 的获取程序窗口中输入的字符的函数汇编语言起始处，其实汇编内容应该是 mov edi, edi</li>
</ul>
</li>
</ul>
<p><img src="/" alt="" class="lazyload" data-src="/images/pasted-11.png"></p>
<ul>
<li>调用函数的传递的参数按<strong>从右往左</strong>的顺序入栈，调用者会清理栈中的参数，返回值放在 eax 寄存器中</li>
</ul>
<p><img src="/" alt="" class="lazyload" data-src="/images/pasted-12.png"></p>
<ul>
<li>对于 GetDlgItemText 这个 API 函数，可以进入函数后在 push eax 时，对 eax 寄存器进行数据跟踪，此后会发现用户输入的内容被传入到内存中</li>
<li><strong>OllyDbg 可以将修改后的汇编代码保存回可执行文件，使用 右击 - 复制到可执行文件</strong></li>
</ul>
<h2 id="常用断点"><a href="#常用断点" class="headerlink" title="常用断点"></a>常用断点</h2><h3 id="INT-3-断点"><a href="#INT-3-断点" class="headerlink" title="INT 3 断点"></a>INT 3 断点</h3><ul>
<li>OD 的 F2 下断点其实就是下了 INT 3 断点，在机器指令中为 0xCC，又称为 CC 断点, 调试器运行到这里的时候会暂停，并将 0xCC 删除（虽然本来也不显示）</li>
<li><font color=red><strong>INT 3 断点容易被程序检测到</strong></font><ul>
<li>使用 C 语言取函数地址，检测首字节的值是否为 0xCC，若是，则程序被下了 CC 断点</li>
<li>将断点下载函数入口的下一行，可以相对难以被程序检测到</li>
</ul>
</li>
</ul>
<h3 id="硬件断点"><a href="#硬件断点" class="headerlink" title="硬件断点"></a>硬件断点</h3><ul>
<li>硬件断点使用了<strong>调试寄存器</strong></li>
<li>右击汇编指令的内存地址，可以在设置硬件执行的断点</li>
<li>也可以右击数据窗口，在内存地址上下某种内存写入方式的硬件断点<ul>
<li>硬件访问 / 写入断点是在<strong>触发硬件断点的下一行处下断</strong></li>
</ul>
</li>
</ul>
<p><img src="/" alt="" class="lazyload" data-src="/images/pasted-13.png"></p>
<ul>
<li>硬件断点的功能类似 CC 断点，但是并不会修改程序原本的汇编指令，因此更难被检测到<ul>
<li><font color=red>**一般只能下4个**</font></li>
</ul>
</li>
<li>在寄存器窗口中，查看调试寄存器，可以查看 DRx 寄存器中的地址值，当我们设置硬件断点，并且程序执行到硬件断点时，DRx 寄存器的值就会发生变化</li>
</ul>
<p><img src="/" alt="" class="lazyload" data-src="/images/pasted-14.png"></p>
<ul>
<li>在 <strong>调试 - 硬件断点</strong> 中可以对硬件断点进行设置</li>
</ul>
<p><img src="/" alt="" class="lazyload" data-src="/images/pasted-15.png"></p>
<h3 id="内存断点"><a href="#内存断点" class="headerlink" title="内存断点"></a>内存断点</h3><ul>
<li>OD 只能下一个内存断点，效率很低</li>
<li>在数据窗口中右击内存地址，可以设置内存访问断点或是内存写入断点，当对此处内存进行操作时下断<ul>
<li>注意，<strong>内存断点是在本行汇编代码执行前下断</strong></li>
</ul>
</li>
</ul>
<h3 id="内存访问一次性断点"><a href="#内存访问一次性断点" class="headerlink" title="内存访问一次性断点"></a>内存访问一次性断点</h3><ul>
<li>使用 Alt + M 显示系统的所有内存块</li>
<li>对某一内存块设置内存访问断点，或是内存写入断点时，当访问到这块内存或者写入这块内存时，断点将被激活，下断后断电被删除</li>
</ul>
<h3 id="消息断点"><a href="#消息断点" class="headerlink" title="消息断点"></a>消息断点</h3><ul>
<li>当某个特定的窗口收到某个特性的消息时，消息断点将使程序中断<ul>
<li><strong>消息断点只有在某个程序启动后才能被设置并拦截</strong></li>
</ul>
</li>
<li><p>当单击一个按钮时，系统会给窗体发送一条消息，内容包括窗口句柄，消息编号，2 个长整型参数，</p>
</li>
<li><p>在 查看 - 窗口 中可以查看当前窗口的所有消息内容，右击刷新更新内容</p>
<ul>
<li>右击可以设置消息断点，比如在按钮上设置，则单击该按钮的时候程序中断</li>
</ul>
</li>
<li><p>如果在第一项上设置断点，将会拦截程序的所有消息</p>
</li>
</ul>
<p><img src="/" alt="" class="lazyload" data-src="/images/pasted-16.png"></p>
<ul>
<li>设置对应的消息类型可以做到更为准确的监听，比如按下按钮后下断</li>
</ul>
<p><img src="/" alt="" class="lazyload" data-src="/images/pasted-17.png"></p>
<h3 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h3><ul>
<li>按寄存器条件中断<ul>
<li>当满足一定条件时，下断的断点称为条件断点<ul>
<li>其实就是带有条件表达式的 INT 3 断点</li>
</ul>
</li>
<li>条件断点添加快捷键 Shift + F2</li>
</ul>
</li>
</ul>
<p><img src="/" alt="" class="lazyload" data-src="/images/pasted-18.png"></p>
<ul>
<li>按存储器条件中断<ul>
<li>在堆栈窗口右击 地址 - 相对于 ESP，可以将堆栈中数据的显示形式改为相对 ESP 的显示形式</li>
<li><img src="/" alt="" class="lazyload" data-src="/images/pasted-19.png"></li>
<li>如果需要访问 ESP 中的参数，例如需要第一个参数的内存地址，方法为 <strong>[ESP + 4]</strong><ul>
<li>如果需要其具体的值，则为 <strong>[STRING [ESP + 4]]</strong></li>
</ul>
</li>
<li>假如 CreateFileA 读取了路径为 “C:\\\1212.txt” 的文件，需要执行中断<ul>
<li>中断条件为 <strong>[STRING [esp + 4]] == “c:\\\1212.txt”</strong></li>
<li>如果是 Unicode 字符串，则为 <strong>[UNICODE [esp + 4]] == “c:\\\1212.txt”</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/" alt="" class="lazyload" data-src="/images/pasted-20.png"></p>
<h3 id="条件记录断点"><a href="#条件记录断点" class="headerlink" title="条件记录断点"></a>条件记录断点</h3><ul>
<li>其功能在条件断点上再加了一些，能记录函数表达式或者参数的值</li>
</ul>
<p><img src="/" alt="" class="lazyload" data-src="/images/pasted-21.png"></p>
<ul>
<li><p>注意 表达式的内容 和 解码表达式的值 需要正确对应</p>
<ul>
<li>假设表达式为 [esp + 4] 则解码表达式的值需要改成 指向 ASCII 字符串的指针</li>
</ul>
</li>
<li><p>暂停程序 用于设置 OD 遇到断点时 是否中断</p>
</li>
<li>记录表达数值 用于设置 遇到断点时是否记录下表达式的值，函数参数同理</li>
<li>条件记录断点允许向插件传递命令，当应用程序因条件断点暂停，并且断点中包含传递给插件的命令时，都会调用回调函数 ODBG_Plugincmd(int reason, t_reg <em>registers, char </em>cmd)<ul>
<li>例如在程序暂停时，需要传递命令 “d esp” 给 CmdBar 插件<ul>
<li>只需要在设置条件断点时，写下”.d esp”</li>
<li>这样我们就可以在数据窗口处看到 esp 地址处的数据了</li>
</ul>
</li>
</ul>
</li>
<li>按 Alt + L 查看记录的数据</li>
</ul>
<p><img src="/" alt="" class="lazyload" data-src="/images/pasted-22.png"></p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="CmdBar-插件"><a href="#CmdBar-插件" class="headerlink" title="CmdBar 插件"></a>CmdBar 插件</h3><div class="table-container">
<table>
<thead>
<tr>
<th>功能</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>? 表达式</td>
<td>计算表达式的结果</td>
</tr>
<tr>
<td>D(DB, DW, DD) 表达式</td>
<td>查看对应的内存数据，例如”d 内存地址” 或 “d esp+4”</td>
</tr>
<tr>
<td>BP 表达式, [条件式]</td>
<td>设置断点，例如 “bp GetDlgItemTextA”</td>
</tr>
<tr>
<td>Hw 表达式</td>
<td>设置硬件断点</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Run-Trace"><a href="#Run-Trace" class="headerlink" title="Run Trace"></a>Run Trace</h2><ul>
<li>Run 跟踪可以跟踪被调试程序执行过的指令，以及地址、寄存器的内容、消息等</li>
<li>它会将这些记录存在 Run 跟踪 缓冲区中</li>
<li><strong>在运行 Run 跟踪 的时候要将缓冲区设置的大一些，否则指令太多时缓冲区会溢出，丢记录</strong></li>
<li>在调试设置中可以调大 Run 跟踪缓冲区的大小</li>
</ul>
<p><img src="/" alt="" class="lazyload" data-src="/images/pasted-23.png"></p>
<ul>
<li>顶栏中的 “…” 可以打开 Run 跟踪 窗口</li>
<li>右键 Run 跟踪 窗口 - 记录到文件 可以将跟踪到的内容保存到文件</li>
<li><p><strong>Run 跟踪 会跟踪程序执行过程中的所有暂停，使用键盘上的 “+” 和 “-“ 可以前后查看执行路线</strong></p>
</li>
<li><p>在被调试程序领空时，在反汇编窗口右键 - Run 跟踪 - 添加所有函数过程入口</p>
<ul>
<li>可以检查每个可识别函数被调用的次数，在 Run 跟踪窗口右击，统计模块中可以看结果</li>
</ul>
</li>
</ul>
<h2 id="Hit-Trace"><a href="#Hit-Trace" class="headerlink" title="Hit Trace"></a>Hit Trace</h2><ul>
<li>Hit Trace 用于记录哪一段代码块被执行过</li>
<li>实现方法也很简单，原理上就是将选中区域的每一条命令下 CC 断点<ul>
<li>中断发生时 OD 会将 CC 断点去除</li>
<li><strong>在使用 Hit Trace 的时候不能在数据中设置断点，否则程序可能会崩溃</strong></li>
</ul>
</li>
<li>对于跳转分支比较多的代码，通过 Hit Trace 可以了解程序的执行线路<ul>
<li>选中需要跟踪的代码，右击 - Hit 跟踪 - 添加选择部分，此后运行时 OD 会标记</li>
</ul>
</li>
</ul>
<p><img src="/" alt="" class="lazyload" data-src="/images/pasted-24.png"></p>
<h2 id="加载程序"><a href="#加载程序" class="headerlink" title="加载程序"></a>加载程序</h2><ul>
<li>OD 有两种方式可以通过加载目标程序进行调试<ul>
<li>一种是通过 CreateProcess 创建进程</li>
<li>另一种是利用 DebugActiveProcess 函数将调试器绑定到正在运行的进程上</li>
</ul>
</li>
</ul>
<h3 id="通过-CreateProcess-创建进程"><a href="#通过-CreateProcess-创建进程" class="headerlink" title="通过 CreateProcess 创建进程"></a>通过 CreateProcess 创建进程</h3><ul>
<li>直接使用 文件 - 打开 启动 exe 程序就行</li>
<li>带参数程序在下方输入参数即可</li>
</ul>
<p><img src="/" alt="" class="lazyload" data-src="/images/pasted-25.png"></p>
<h3 id="通过-DebugActiveProcess-附在正在运行的进程上"><a href="#通过-DebugActiveProcess-附在正在运行的进程上" class="headerlink" title="通过 DebugActiveProcess 附在正在运行的进程上"></a>通过 DebugActiveProcess 附在正在运行的进程上</h3><ul>
<li>通过 文件 - 附加 选择进程即可进行附加</li>
<li>对于隐藏进程的附加需要启动参数 -p 进程的 pid</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Ollydbg.exe <span class="literal">-p</span> <span class="number">1234</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果附加不成功，可以利用 OD 的即时调试器进行调试<ul>
<li>例如有个会调用 B.exe 的程序 A.exe，运行 A.exe</li>
<li>使用 OD 附加 B.exe，这时候 OD 会假死，在 OD 设置中将其调整为 即时调试器</li>
<li>将 B.exe 的入口改为 CC 断点，记下原指令</li>
<li>运行 A.exe 的时候，B.exe 被调用，出现程序中断</li>
<li>OD 作为即时调试器启动并加载 B.exe</li>
<li>将 CC 恢复成原指令后继续调试</li>
</ul>
</li>
</ul>
<h2 id="OllyDbg-常见问题"><a href="#OllyDbg-常见问题" class="headerlink" title="OllyDbg 常见问题"></a>OllyDbg 常见问题</h2><h3 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h3><ul>
<li>假设使用 OD 跟踪程序时出现了如下情况</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>004010CC</th>
<th>55</th>
<th>db</th>
<th>55</th>
</tr>
</thead>
<tbody>
<tr>
<td>004010CD</td>
<td>8B</td>
<td>db</td>
<td>8B</td>
</tr>
<tr>
<td>004010CE</td>
<td>EC</td>
<td>db</td>
<td>EC</td>
</tr>
<tr>
<td>004010CF</td>
<td>83</td>
<td>db</td>
<td>83</td>
</tr>
<tr>
<td>004010D0</td>
<td>56</td>
<td>db</td>
<td>56</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>但是没有显示正常的汇编指令</li>
<li>使用 Ctrl A 可以重新分析代码</li>
<li>如果还是没有作用，就在 UDD 目录中删除此程序的记录文件</li>
</ul>
<h3 id="快速回到程序领空"><a href="#快速回到程序领空" class="headerlink" title="快速回到程序领空"></a>快速回到程序领空</h3><ul>
<li>双击 EIP 中的记录值</li>
</ul>
<h3 id="修改-EIP-的值"><a href="#修改-EIP-的值" class="headerlink" title="修改 EIP 的值"></a>修改 EIP 的值</h3><ul>
<li>右键目标地址，把 EIP 值改过来就好了</li>
</ul>
<h3 id="在反汇编窗口输入-push-E000-之类的指令报错"><a href="#在反汇编窗口输入-push-E000-之类的指令报错" class="headerlink" title="在反汇编窗口输入 push E000 之类的指令报错"></a>在反汇编窗口输入 push E000 之类的指令报错</h3><ul>
<li>改成 push 0E000</li>
</ul>
<h3 id="重命名-call-函数名"><a href="#重命名-call-函数名" class="headerlink" title="重命名 call 函数名"></a>重命名 call 函数名</h3><ul>
<li>例如 call 401496，点击此处，使用 “Shift + ;” 重命名</li>
</ul>
<h3 id="设置-OllyDbg-为即时调试器"><a href="#设置-OllyDbg-为即时调试器" class="headerlink" title="设置 OllyDbg 为即时调试器"></a>设置 OllyDbg 为即时调试器</h3><ul>
<li>在 设置 - 实时调试设置 里设置</li>
</ul>
<p><img src="/" alt="" class="lazyload" data-src="/images/pasted-26.png"></p>
<h1 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h1><h2 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h2><p><img src="/" alt="" class="lazyload" data-src="/images/pasted-27.png"></p>
<ul>
<li>可以通过导航栏快速访问代码</li>
<li>右键可以放大缩小</li>
</ul>
<h2 id="输入函数"><a href="#输入函数" class="headerlink" title="输入函数"></a>输入函数</h2><ul>
<li>在 视图 - 打开子视图 中可以打开输入函数</li>
<li>其中可以查看可执行文件调用的所有函数以及包含该函数的库名称和函数地址</li>
</ul>
<p><img src="/" alt="" class="lazyload" data-src="/images/pasted-28.png"></p>
<h2 id="跳转到目标地址"><a href="#跳转到目标地址" class="headerlink" title="跳转到目标地址"></a>跳转到目标地址</h2><ul>
<li>快捷键 G </li>
</ul>
<h2 id="交叉参考-XREF"><a href="#交叉参考-XREF" class="headerlink" title="交叉参考 (XREF)"></a>交叉参考 (XREF)</h2><p><img src="/" alt="" class="lazyload" data-src="/images/pasted-29.png"></p>
<ul>
<li>此处表示数据交叉，还有 代码交叉 等</li>
<li>其中 ↑ 后的字母 o 表示偏移量，j 则是跳转，p 则为子程序</li>
<li><p>双击箭头跳转</p>
</li>
<li><p>点击函数按 X 键可以打开交叉参考窗口</p>
</li>
</ul>
<h3 id="参考重命名"><a href="#参考重命名" class="headerlink" title="参考重命名"></a>参考重命名</h3><ul>
<li>就是重命名函数，右键函数点击重命名就会执行全局重命名</li>
</ul>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><ul>
<li>使用快捷键 Alt + M 可以在光标处设置标签</li>
<li>使用 Ctrl + M 可以打开已有标签窗口执行快速跳转</li>
</ul>
<h2 id="格式化指令操作数"><a href="#格式化指令操作数" class="headerlink" title="格式化指令操作数"></a>格式化指令操作数</h2><ul>
<li>右键具体值，可以改变值的进制</li>
<li>在使用标识符号常量中可以设置宏定义的值</li>
</ul>
<h2 id="代码和数据转换"><a href="#代码和数据转换" class="headerlink" title="代码和数据转换"></a>代码和数据转换</h2><ul>
<li>IDA 有可能错误的把数据字节和代码字节错误转换</li>
<li>在 编辑 - 转换为数据/代码 可以将反汇编得到的汇编代码进行转换<ul>
<li>快捷键 C 可以将数据字节转换成<strong>代码字节</strong></li>
<li>快捷键 P 可以将某段代码定义为<strong>子程序</strong></li>
<li>快捷键 U 可以取消这一块的定义，数据将重新变成十六进制的形式</li>
<li><strong>快捷键 D 可以将数据在 db, dw, dd 中转换</strong><ul>
<li>在 选项 - 设置数据类型 中可以设置参与转换的数据类型</li>
</ul>
</li>
<li>快捷键 A 将数据转换为字符串</li>
</ul>
</li>
</ul>
<h2 id="数组处理"><a href="#数组处理" class="headerlink" title="数组处理"></a>数组处理</h2><ul>
<li>快捷键 * 可以快速将一块的数据转换成数组进行处理</li>
</ul>
<p><img src="/" alt="" class="lazyload" data-src="/images/pasted-30.png"></p>
<h2 id="结构体处理"><a href="#结构体处理" class="headerlink" title="结构体处理"></a>结构体处理</h2><ul>
<li>在 视图 - 打开子视图 - 结构体 中，可以设置结构体<ul>
<li>快捷键为 Shift + F9</li>
</ul>
</li>
<li><p>结构体窗口中，使用 Insert 可以添加结构体，其中可以添加 标准结构体</p>
</li>
<li><p>对于 IDA 没有转换其为结构体的结构体数据 </p>
</li>
</ul>
<p><img src="/" alt="" class="lazyload" data-src="/images/pasted-31.png"></p>
<ul>
<li>可以在结构体窗口中添加一个自定义结构体<ul>
<li>快捷键 Insert</li>
<li>光标停留在 ends 处，按 D 添加整形，按 A 设置字符串大小添加字符串类型</li>
<li>使用 U 来删除某段定义</li>
<li>使用 Alt + Q 来实现结构体嵌套</li>
</ul>
</li>
</ul>
<p><img src="/" alt="" class="lazyload" data-src="/images/pasted-32.png"></p>
<ul>
<li>此后便可以将数据转为结构体显示<ul>
<li>在 编辑 - 结构体 - 结构体变量 进行修改</li>
</ul>
</li>
</ul>
<p><img src="/" alt="" class="lazyload" data-src="/images/pasted-33.png"></p>
<ul>
<li>设置完后，对于 main 中的内容可以使用 T 键快速将偏移量设置为结构体偏移量</li>
</ul>
<p><img src="/" alt="" class="lazyload" data-src="/images/pasted-34.png"></p>
<ul>
<li><p>选中所有需要替换的内容，按 T 或者从 编辑 - 操作数类型 - 偏移量 - 偏移量(结构体) 可以批量修改类型</p>
</li>
<li><p>共用体的创建方法也类似</p>
</li>
</ul>
<h3 id="导入结构体"><a href="#导入结构体" class="headerlink" title="导入结构体"></a>导入结构体</h3><ul>
<li>通过 文件 - 加载文件 - 分析 C 头文件 可以载入头文件中的结构体</li>
</ul>
<h2 id="枚举类型处理"><a href="#枚举类型处理" class="headerlink" title="枚举类型处理"></a>枚举类型处理</h2><ul>
<li><p>对于枚举类型， IDA 只会显示其对应的值，不会得到原来的枚举变量</p>
</li>
<li><p>在 视图 - 打开子视图 - 枚举 中可以使用 Insert 新建枚举类型</p>
</li>
<li>使用快捷键 N 新建值</li>
<li>在反汇编窗口中使用 M 将值修改为枚举值</li>
</ul>
<h2 id="库文件快速识别与鉴定技术-FLIRT"><a href="#库文件快速识别与鉴定技术-FLIRT" class="headerlink" title="库文件快速识别与鉴定技术 (FLIRT)"></a>库文件快速识别与鉴定技术 (FLIRT)</h2><ul>
<li>IDA 会通过搜索已有的库函数对程序中调用的函数进行重命名</li>
<li>使用 Shift + F5 可以添加更多的签名，让 IDA 根据签名更好的标注函数</li>
</ul>
<h2 id="IDA-调试器"><a href="#IDA-调试器" class="headerlink" title="IDA 调试器"></a>IDA 调试器</h2><ul>
<li>IDA 可以借助调试器实现动态调试程序的效果</li>
<li>快捷键如下</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>F7</td>
<td>单步步进</td>
</tr>
<tr>
<td>F8</td>
<td>单步步过</td>
</tr>
<tr>
<td>F4</td>
<td>运行到光标所在行</td>
</tr>
<tr>
<td>Ctrl + F7</td>
<td>运行到该函数返回</td>
</tr>
<tr>
<td>F9</td>
<td>运行程序</td>
</tr>
<tr>
<td>Ctrl + F2</td>
<td>终止进程</td>
</tr>
<tr>
<td>F2</td>
<td>下断点</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>下断点时可以设置断点启用条件</li>
</ul>
<p><img src="/" alt="" class="lazyload" data-src="/images/pasted-35.png"></p>
<h2 id="修补程序"><a href="#修补程序" class="headerlink" title="修补程序"></a>修补程序</h2><ul>
<li>IDA 在 Edit - Patch Program - Assemble 中可以修补原来的程序</li>
</ul>
<h2 id="重新设置基址"><a href="#重新设置基址" class="headerlink" title="重新设置基址"></a>重新设置基址</h2><ul>
<li>在 编辑 - 段 - 重新设置基址 中调整，可以配合 OD 进行调试</li>
</ul>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><ul>
<li>call 指令与 jmp 指令不同的是，call 指令在跳转之前会将此指令的下一条指令地址压入栈顶</li>
<li>当子程序执行 ret 指令时，函数会根据栈中保存的地址进行跳转</li>
</ul>
<h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><ul>
<li>函数可以通过栈、寄存器或是全局变量的方式传递参数<ul>
<li>函数用栈还是寄存器的方式来传递参数，与编译语言有关</li>
</ul>
</li>
</ul>
<h3 id="利用栈传递参数"><a href="#利用栈传递参数" class="headerlink" title="利用栈传递参数"></a>利用栈传递参数</h3><ul>
<li>栈顶指针 esp 指向栈中的第一个可用数据项</li>
<li>函数调用结束后，调用着或是函数本身会将栈中的多于元素处理，使栈平衡</li>
<li>当参数多余一个时，将参数压入栈的顺序根据语言不同而不同</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>约定类型</th>
<th>参数传递顺序</th>
<th>平衡栈者</th>
<th>允许使用VARARG(不定个数参数)</th>
</tr>
</thead>
<tbody>
<tr>
<td>__cdecl</td>
<td>从右到左</td>
<td>调用者</td>
<td>是</td>
</tr>
<tr>
<td>pascal</td>
<td>从左到右</td>
<td>子程序</td>
<td>否</td>
</tr>
<tr>
<td>stdcall</td>
<td>从右到左</td>
<td>子程序</td>
<td>否</td>
</tr>
<tr>
<td>Fastcall</td>
<td>使用寄存器和栈</td>
<td>子程序</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>__cdecl 是 C 和 C++ 的默认调用约定</li>
<li><p>stdcall 是 Win32 API 采用的约定方式，结合了 pascal 的调用栈指针方式和 C 约定的入栈顺序</p>
<ul>
<li>Win32 API 也有使用 __cdecl 调用方式的函数，例如 wsprintf</li>
</ul>
</li>
<li><p>对于同样的函数调用，例如 test1(p1, p2, p3)，汇编代码如下</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>__cdecl</th>
<th>pascal</th>
<th>stdcall</th>
</tr>
</thead>
<tbody>
<tr>
<td>push p3  ;参数从右往左传递<br />push p2<br />push p1<br />call test1<br />add esp, 0C  ;平衡栈</td>
<td>push p1  ;参数从左往右传递<br />push p2<br />push p3<br />call test1 ;函数内平衡栈</td>
<td>push p3 ;参数从右往左传递<br />push p2<br />push p1<br />call test1 ;函数内平衡栈</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>栈的生长方式为高地址向低地址生长，因此向栈中 push 参数时，esp 指向的地址相当于减小了</p>
<ul>
<li>正因此平衡栈时才使用 add esp, 0C 这种方式，0C 为 12，刚好 3 个 int 参数大小</li>
</ul>
</li>
<li><p>子程序执行过程大致如下</p>
</li>
</ul>
<ol>
<li>调用者将函数执行完毕时应返回的地址、参数压入栈</li>
<li>子程序使用 <strong>ebp 指针 + 偏移量</strong> 对栈中的参数进行寻址并取出</li>
<li>子程序执行完 ret 后，CPU 将 EIP 置为栈中保存的返回地址，并继续执行</li>
</ol>
<ul>
<li>按照 stdcall 方式调用子函数的汇编代码如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">push p2										;参数2 入栈</span><br><span class="line">push p1										;参数1 入栈</span><br><span class="line">call tast2</span><br><span class="line">&#123;</span><br><span class="line">		push ebp							;保护现场原来的 ebp 指针</span><br><span class="line">		mov ebp, esp						;设置新的 ebp 指针，指向当前栈顶</span><br><span class="line">		mov eax, dword ptr [ebp+0C]			;调用参数 2</span><br><span class="line">		mov eax, dword ptr [ebp+08]			;调用参数 1</span><br><span class="line">		sub esp, 8							;为局部变量开辟空间</span><br><span class="line">		......</span><br><span class="line">		add esp, 8							;释放局部变量空间</span><br><span class="line">		pop ebp								;恢复现场的 ebp 指针</span><br><span class="line">		ret 8								;返回，相当于 ret; add esp, 8</span><br><span class="line">&#125;											;ret 后的值相当于参数个数乘以 4h</span><br></pre></td></tr></table></figure>
<ul>
<li>为局部变量开辟完空间后栈中的内容如下</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>地址 (设最开始为 K)</th>
<th>栈中内容</th>
<th>偏移量地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>K</td>
<td>……</td>
<td>起始栈</td>
</tr>
<tr>
<td>K - 04h</td>
<td>p2</td>
<td>ebp + Ch</td>
</tr>
<tr>
<td>K - 08h</td>
<td>p1</td>
<td>ebp + 8h</td>
</tr>
<tr>
<td>K - 0Ch</td>
<td>返回地址</td>
<td>ebp + 4h</td>
</tr>
<tr>
<td>K - 10h</td>
<td>保存的 ebp</td>
<td>ebp + 0h</td>
</tr>
<tr>
<td>K - 14h</td>
<td>局部变量1</td>
<td>ebp - 4h</td>
</tr>
<tr>
<td>K - 18h</td>
<td>局部变量2</td>
<td>ebp - 8h</td>
</tr>
<tr>
<td>esp</td>
<td>……</td>
<td>当前 esp 指针指向的内容</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>一般使用 enter 代替 push ebp; mov ebp, esp; sub esp, xxx</li>
<li><p>使用 leave 代替 add esp, xxx; pop ebp</p>
</li>
<li><p>所以一般调用子程序时使用的代码如下</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enter xxx, 0			;0 表示创建 xxx 的空间来放置局部变量</span><br><span class="line">......</span><br><span class="line">leave					;恢复现场</span><br><span class="line">ret xxx</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 O2 优化的话编译后会尽可能地节省寄存器空间和汇编语句</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">push p2</span><br><span class="line">push p1</span><br><span class="line">call test2</span><br><span class="line">&#123;</span><br><span class="line">		mov eax, dword ptr [esp+04]</span><br><span class="line">		mov ecx, dword ptr [esp+08]</span><br><span class="line">		......</span><br><span class="line">		ret 8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这时候程序全靠 esp 来传递参数</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>地址 (设最开始为 K)</th>
<th>栈中内容</th>
<th>偏移量地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>K</td>
<td>……</td>
<td>起始栈</td>
</tr>
<tr>
<td>K - 04h</td>
<td>p2</td>
<td>esp + 8h</td>
</tr>
<tr>
<td>K - 08h</td>
<td>p1</td>
<td>esp + 4h</td>
</tr>
<tr>
<td>K - 0Ch</td>
<td>返回地址</td>
<td>当前 esp 指针指向的地址</td>
</tr>
</tbody>
</table>
</div>
<h3 id="利用寄存器传递参数"><a href="#利用寄存器传递参数" class="headerlink" title="利用寄存器传递参数"></a>利用寄存器传递参数</h3><ul>
<li>不同的编译器利用的方式不一样</li>
<li>声明方法</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>汇编代码中 lea 代表 Load Effective Address</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lea eax, dword ptr[esp+04]		;eax 指向 esp+04h 的地址</span><br></pre></td></tr></table></figure>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li>程序使用 sub esp, xxx 的方式来给局部变量分配空间，此后使用 ebp-xxx 的方式读取局部变量<ul>
<li>函数参数调用对于 ebp 来说是正的，一般为 ebp+xxx</li>
</ul>
</li>
<li>栈会占用两个寄存器</li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><ul>
<li><p>C++ 中存在一种面向对象的概念，称为虚函数</p>
<ul>
<li>虚函数的地址不在编译时确定，而在即将调用的时候确定</li>
<li>对虚函数的引用存在 虚函数表(VTBL) 中<ul>
<li>其实是个数组</li>
</ul>
</li>
<li>VTBL 中的每个元素就是对应虚函数的地址</li>
<li>调用虚函数的时候，程序先取出 VTBL 的指针，再取出该函数的地址，最后调用该函数</li>
</ul>
</li>
<li><p>虚函数的 C++ 代码声明方式如下</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:bi0x@foxmail.com">Bi0x</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.bi0x.cn/2020/04/02/reverse1/">http://www.bi0x.cn/2020/04/02/reverse1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.bi0x.cn" target="_blank">Bi0x</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Re/">Re    </a></div><div class="post_share"><div class="social-share" data-image="/images/pasted-41.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/04/13/python1/"><img class="prev_cover lazyload" data-src="/images/pasted-37.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">蟒蛇们</div></div></a></div><div class="next-post pull_right"><a href="/2020/03/31/stack-overflow/"><img class="next_cover lazyload" data-src="/images/pasted-9.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">各种栈溢出</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify: false,
  verify: false,
  appId: 'J91TT6tmiySm3lUixVOE4CbJ-gzGzoHsz',
  appKey: 'MidtPXnwEq70NCNqga98erKe',
  placeholder: 'Please leave your footprints',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'zh-cn',
  recordIP: false,
  serverURLs: ''
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Bi0x</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">到这里结束了呢</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/click_heart.js"></script><script>if (document.getElementsByClassName('mermaid').length) {
  loadScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js',function () {
    mermaid.initialize({
      theme: 'default',
  })
})
}</script></body></html>